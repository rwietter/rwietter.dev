---
title: Dissecando o mecanismo de alinhamento de bytes e padroniza√ß√£o de padding para coer√™ncia espacial-temporal e otimiza√ß√£o de espa√ßo em Golang.
description:
slug: dissecando-o-mecanismo-de-alinhamento-de-bytes-e-padronizacao-de-padding-para-coerencia-espacial-temporal-e-otimizacao-de-espaco-em-golang
image:
alternativeText:
caption:
publishedAt: 2024-11-13
updatedAt: 2024-11-16
category: theory
author: Maur√≠cio Witter
keywords:
---

# 1 Introdu√ß√£o

**Data Alignment** n√£o √© um assunto popular entre grande parte dos desenvolvedores, mas est√° longe de ser um assunto herm√©tico/abstruso e n√£o precisar ser um conhecimento esot√©rico. Mas esse assunto costuma estar long√≠nquo da base que √© ensinada em cursos universit√°rios e _bootcamps_. Vamos jogar luz sobre ele e entender melhor como a mem√≥ria √© organizada e como o alinhamento de dados pode afetar o desempenho do seu c√≥digo.

# 2 Arquitetura Computacional

O alinhamento de dados/bytes est√° intrinsecamente relacionado ao hardware, √† mem√≥ria virtual, ou como o sistema operacional a v√™ e ger√™ncia. Isso porque, dependendo da arquitetura, h√° uma padroniza√ß√£o de `word-size` e instru√ß√µes espec√≠ficos para cada arquitetura. Por exemplo, em arquiteturas x86-64, a CPU trabalha com 8 bytes (ou 64 bits) por ciclo. Mas por que 8 bytes? Bem, isso est√° relacionado ao fato de que sistemas computacionais operam com dados em [formato bin√°rio](https://www.wikiwand.com/pt/articles/Sistema_de_numera%C3%A7%C3%A3o_bin%C3%A1rio), ou seja, em pot√™ncias de 2 e 64 bits ‚Äî a gera√ß√£o seguinte da x86 (32 bits). A padroniza√ß√£o facilita o processamento eficiente e otimiza o acesso √† mem√≥ria, pois mant√©m as instru√ß√µes e dados alinhados com a largura do barramento de dados[^2][^3] da arquitetura e dos registradores.

<Cite>
"Muitos sistemas de computador imp√µem restri√ß√µes aos endere√ßos permitidos para os tipos de dados primitivos, exigindo que o endere√ßo de algum tipo de objeto seja um m√∫ltiplo de algum valor K (normalmente 2, 4 ou 8)"[^1].
</Cite>

Em sistemas de 32 bits (x86), a CPU trabalha com 4 bytes (32 bits) por ciclo. Nesse caso, o alinhamento de dados em m√∫ltiplos de 4 bytes garante um acesso eficiente, evitando penalidades de desempenho. Arquiteturas de 16 bits, comuns em sistemas embarcados mais antigos, trabalha com 2 bytes (16 bits) por ciclo, enquanto em arquiteturas de 8 bits, a unidade m√≠nima √© de 1 byte por ciclo. H√°, tamb√©m, outras diversas arquiteturas que trabalham com 128 bits, 256 bits e assim por diante.

Portanto, o alinhamento de dados √© determinado pela arquitetura, tudo precisa estar se comunicando na mesma linguagem para que o sistema computacional como um todo possa trabalhar em harm√¥nia, evitando problemas de desempenho que ocorrem quando os dados est√£o desalinhados.

# 3 Data Alignment

Consoantemente ao pr√≥prio nome, **Data Alignment** refere-se ao nivelamento dos dados na mem√≥ria para que eles sejam m√∫ltiplos do tamanho do seu pr√≥prio tipo ou de um m√∫ltiplo de algum valor K (2, 4 ou 8). Isso permite que a CPU acesse os dados em menos ciclos, pois o alinhamento garante que os dados sejam lidos ou escritos sem penalidades, aproveitando o tamanho da `word-size` da arquitetura.

<Cite>
"Por exemplo, suponha que um processador sempre busque 8 bytes da mem√≥ria com um endere√ßo que deve ser m√∫ltiplo de 8. Se pudermos garantir que qualquer `double` esteja alinhado para ter seu endere√ßo m√∫ltiplo de 8, ent√£o o valor pode ser lido ou escrito com uma √∫nica opera√ß√£o de mem√≥ria. Caso contr√°rio, poderemos precisar realizar dois acessos √† mem√≥ria, uma vez que o objeto pode ser dividido em dois blocos de mem√≥ria de 8 bytes."[^1]
</Cite>

Dadas as defini√ß√µes inciais, vamos entender como isso de fato funciona, n√£o √© mesmo ? Categoricamente, para compreender como fazer o alinhamento de bytes, precisamos saber para qual arquitetura estamos compilando, quantos bytes os tipos da linguagem ocupam e quais diretivas o compilador adota para alinhar os bytes.

Para este post, estarei utilizando uma arquitetura x86-64; como linguagem ‚Äî Golang ‚Äî para ilustrar os exemplos. Na se√ß√£o [3.1 Diretivas de Alinhamento](#31-diretivas-de-alinhamento), est√£o dispostos os tipos da linguagem e seus respectivos tamanhos e as regras de alinhamento do [compilador Go](https://github.com/golang/go).

## 3.1 Diretivas de Alinhamento

### 3.1.1 Diretivas Gerais

- **Alinhamento Padr√£o**: O alinhamento de um tipo √© determinado pelo tamanho do seu maior campo, at√© um m√°ximo de 8 bytes (o tamanho de um ponteiro em arquiteturas de 64 bits).

- **Arredondamento**: O tamanho de um tipo √© sempre arredondado para cima para ser um m√∫ltiplo do seu alinhamento. Isso garante que os tipos sejam armazenados em endere√ßos de mem√≥ria adequados.

### 3.1.2 Diretivas de Alinhamento Espec√≠ficos

- `int8`, `uint8`, `bool`: Tamanho 1 byte, alinhamento 1 byte.
- `int16`, `uint16`: Tamanho 2 bytes, alinhamento 2 bytes.
- `int32`, `uint32`, `float32`: Tamanho 4 bytes, alinhamento 4 bytes.
- `int64`, `uint64`, `float64`, `complex128`: Tamanho 8 bytes, alinhamento igual ao tamanho da `word-size` da m√°quina (definido por `RegSize`).
- `complex64`: Tamanho 8 bytes, alinhamento 4 bytes.
- **Pointers** (`*T`, `unsafe.Pointer`): Tamanho e alinhamento iguais ao tamanho de um ponteiro (`PtrSize`).
- **Interfaces** (`interface{}`): Tamanho igual a dois ponteiros, alinhamento igual ao tamanho de um ponteiro.
- **Arrays** (`[n]T`): O tamanho √© um m√∫ltiplo do tamanho do elemento. O alinhamento √© igual ao alinhamento do elemento.
- **Structs** (`struct{...}`):
    - O alinhamento de uma estrutura √© o maior alinhamento de qualquer um dos seus campos.
    - O tamanho de uma struct √© o deslocamento do √∫ltimo campo, arredondado para cima para ser um m√∫ltiplo do alinhamento da struct.
    - Padding pode ser adicionado entre os campos de uma estrutura para garantir o alinhamento correto dos campos.
- **Strings** (`string`): Tamanho e alinhamento iguais ao tamanho de um ponteiro.
- **Slices** (`[]T`): Tamanho de tr√™s ponteiros, alinhamento igual ao tamanho de um ponteiro.
- **Channel** (`chan T`): Tamanho e alinhamento iguais ao tamanho de um ponteiro.
- **Maps** (`map[K]V`): Tamanho e alinhamento iguais ao tamanho de um ponteiro.

<Warn title="Attention">
As vari√°veis `PtrSize` e `RegSize` s√£o definidas em **Build Time**, logo, s√£o do tamanho do `word-size` da arquitetura alvo.
</Warn>

Fechando esse hiato de conhecimento, agora finalmente podemos ir para a parte pr√°tica e ver como isso se aplica ao nosso c√≥digo.

## 3.2 Alinhamento pr√°tico

Na `Transaction` abaixo, defini alguns campos com tipos e seus respectivos tamanhos para entendermos o que h√° de errado com ela e depois iremos corrigir.

```go
type Transaction struct {
	Operation byte
	Quantity  int16
	Total     float64
	UnitPrice float32
	Balance   complex128
}
```

Bom, n√≥s j√° conhecemos o tipos e seus respectivos tamanhos, certo? Abordamos eles na se√ß√£o [3.1](#31-diretivas-de-alinhamento), ent√£o se somarmos esses tamanhos, teremos o tamanho total da nossa `struct`, correto?

$$
\begin{align*}
\text{Transaction} = & \ \text{byte} + \text{int16} + \text{float64} + \text{float32} + \text{complex128} \\
\text{Transaction} = & \ 1 + 2 + 8 + 4 + 16 \\
\text{Transaction} = & \ 31 \text{ bytes}
\end{align*}
$$

Ent√£o ter√≠amos $31 \ bytes$ e nossa "mem√≥ria m√°gica" pareceria algo assim. Cada bloco representando $1 \ byte$, `operation` ocupando 1 bloco, `quantity` 2 blocos, `total` 8 blocos, `unitPrice` 4 blocos e `balance` 16 blocos.

<Figure
  source="/assets/magic-memory.png"
  id="1"
  lang="pt"
  alt="Representa√ß√£o dos blocos de mem√≥ria se n√£o houvesse qualquer alinhamento de bytes."
  caption="Representa√ß√£o dos blocos de mem√≥ria se n√£o houvesse qualquer alinhamento de bytes."
/>

## 3.3 Padding Bytes

Em teoria, a struct `Transaction` deveria ter $31 \ bytes$, mas se verificarmos o tamanho da `struct`, veremos que ela tem $40 \ bytes$ ‚Äî ü§®. O que h√° de errado? Bem, nada üôÉ. Ocorre que, nossos campos da `struct` n√£o est√£o alinhados, ent√£o o compilador adicionou lacunas extras (**paddings** ou **gaps**) entre eles, para garantir que os campos estejam alinhados.

```go
func main() {
	fmt.Printf("Struct Size: %d bytes\n", reflect.TypeOf(Transaction{}).Size())
	fmt.Println()
	t := reflect.TypeOf(Transaction{})
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(
      "Field: %s,
      Type: %s,
      Size: %d bytes\n",
      field.Name,
      field.Type,
      field.Type.Size()
    )
	}
}
```

```bash
go run main.go
# Struct Size: 40 bytes

# Field: Operation, Type: uint8, Size: 1 bytes
# Field: Quantity, Type: int16, Size: 2 bytes
# Field: Total, Type: float64, Size: 8 bytes
# Field: UnitPrice, Type: float32, Size: 4 bytes
# Field: Balance, Type: complex128, Size: 16 bytes
```

Como resultado de alinhamento, o [go](https://go.dev/) adicionou essas lacunas entre os campos, mas n√£o precisou arredondar a estrutura final porque ela j√° termina alinhada, com o pr√≥ximo **offset** sendo um m√∫ltiplo de $8$ ‚Äî o $40$. Nossa mem√≥ria agora seria algo assim:

<Figure
  source="/assets/memory-alignment-40-bytes.png"
  id="2"
  lang="pt"
  caption="Representa√ß√£o dos blocos de mem√≥ria com padding bytes. 1 bloco (unit8), 1 bloco de padding, 2 blocos (int16), 4 blocos padding, 8 blocos (float64), 4 blocos (float32), 4 blocos de padding, 16 blocos (complex128)."
  alt="Representa√ß√£o dos blocos de mem√≥ria com padding bytes. 1 bloco (unit8), 1 bloco de padding, 2 blocos (int16), 4 blocos padding, 8 blocos (float64), 4 blocos (float32), 4 blocos de padding, 16 blocos (complex128)."
/>


1. **`Operation` (byte):** Ocupa o bloco 1 (offset 0).
2. **`Quantity` (int16):**  Precisa ser alinhado em um endere√ßo m√∫ltiplo de 2 (tamanho de um `int16`). Como o offset atual √© 1, o compilador adicionar√° **1 byte de padding** no bloco 2 para garantir o alinhamento correto de `Quantity` no bloco 3 (offset 2).
3. **`Total` (float64):** Requer alinhamento de 8 bytes. O pr√≥ximo offset dispon√≠vel ap√≥s `Quantity` seria o 4 (bloco 5), mas ele precisa ser alinhado em um m√∫ltiplo de 8.  Portanto, haver√° **4 bytes de padding** (blocos 4, 5, 6 e 7) antes de `Total`.
4. **`UnitPrice` (float32):**  Segue `Total` diretamente, ocupando 4 bytes e mantendo o alinhamento.
5. **`Balance` (complex128):**  Esse tipo √© 16 bytes, mas a diretiva diz que ele √© alinhado `RegSize`, na minha m√°quina (x84-64), isso √© 8 bytes, como o offset ap√≥s `UnitPrice` j√° √© m√∫ltiplo de 8, ele se encaixa perfeitamente sem a necessidade de padding adicional.

Se somarmos os tamanhos dos campos e os bytes de padding, teremos o tamanho total da `struct`:

$$
\begin{align*}
\text{Transaction} = & \ \text{byte} + \text{int16} + \text{float64} + \text{float32} + \text{complex128} \\
\text{Transaction} = & \ 1 + 2 + 8 + 4 + 16 \\
\text{Transaction} = & \ 31 \text{ bytes} + 1 \text{ byte} + 4 \text{ bytes} + 4 \text{ bytes} \\
\text{Transaction} = & \ 40 \text{ bytes}
\end{align*}
$$

Como resultado final ter√≠amos uma `struct` de $40 \ bytes$, que poder√≠amos representar assim:

```go
type TAlignment struct {
	Operation byte       // 0x00
	_         [1]byte    // 0x01
	Quantity  int16      // 0x02 - 0x03
	_         [4]byte    // 0x04 - 0x07
	Total     float64    // 0x08 - 0x0F
	UnitPrice float32    // 0x10 - 0x13
	_         [4]byte    // 0x14 - 0x17
	Balance   complex128 // 0x18 - 0x27
} // Total: 40 bytes
```

## 3.4 Pointer Bytes

Ponteiros s√£o um caso especial, pois o tamanho de um ponteiro √© o mesmo que o tamanho da `word-size` da arquitetura. Assim sendo, o alinhamento de um ponteiro √© o mesmo que o tamanho de um ponteiro. Em rotinas que alocam mem√≥ria, como `malloc` em [C](https://www.iso.org/standard/82075.html) ou `make`,  `slices`, `maps` e `channels` em [Go](https://go.dev/). Assim sendo, o ponteiro retornado deve satisfazer a restri√ß√£o de alinhamento de pior caso para a m√°quina em que est√° sendo compilada.

<Cite>
As rotinas de biblioteca que alocam mem√≥ria, como malloc, devem ser projetadas de modo que retornem um ponteiro que satisfa√ßa a restri√ß√£o de alinhamento de pior caso para a m√°quina em que est√° sendo executada, normalmente 4 ou 8 bytes[^1].
</Cite>

### 3.4.1 Garbage Collection

O [Garbage Collector](https://tip.golang.org/doc/gc-guide) ‚Äî GC ‚Äî fica varrendo a mem√≥ria em busca de ponteiros para objetos que n√£o est√£o mais sendo usados. Dependendo de como o layout de mem√≥ria da sua aplica√ß√£o est√°, o GC pode precisar varrer mais bytes do que o necess√°rio, causando um overhead desnecess√°rio.

```go
type Token struct {
	File  *string
	Line  int
	Type  int
	Value []byte
}
```

Ent√£o qual √© a ideia aqui ü§î ? A indica√ß√£o √© para que se **adicione pointer bytes por primeiro** na struct.

## Padroniza√ß√£o de padding

## Coer√™ncia espacial-temporal

## Otimiza√ß√£o de espa√ßo

## Benchmarks

---

## Alinhamento

Em primeiro lugar, devemos estar cientes de que o alinhamento depende da arquitetura do processador, incluindo o tamanho da palavra que o processador pode processar diretamente. Em arquiteturas de 32 bits, o processador trabalha com palavras de 4 bytes (32 bits) e, em arquiteturas de 64 bits, com palavras de 8 bytes (64 bits). Isso influencia os requisitos de alinhamento e acesso eficiente √† mem√≥ria, mas o n√∫mero de opera√ß√µes realizadas por ciclo de clock depende de muitos outros fatores al√©m do tamanho da palavra.

### Endere√ßo Alinhado

Se um valor de tipo X come√ßa em um endere√ßo que √© m√∫ltiplo de 8 (para uma arquitetura de 64 bits), o processador pode acessar a mem√≥ria em um √∫nico ciclo, pois o valor cabe completamente dentro de um √∫nico bloco de mem√≥ria de 64 bits, do contr√°rio o processador precisar√° fazer acessos adicionais √† mem√≥ria.

## Endere√ßo Desalinhado

Se o valor come√ßar em um endere√ßo √≠mpar ou um endere√ßo que n√£o seja m√∫ltiplo de 8, o valor pode estar "quebrado" entre dois blocos de 64 bits. Neste caso, o processador ter√° que realizar dois acessos √† mem√≥ria para ler partes do dado de dois blocos diferentes.

Suponha que voc√™ tenha um valor de 64 bits (8 bytes) e ele esteja armazenado come√ßando no endere√ßo 9 (um endere√ßo √≠mpar). O processador ter√° que acessar o bloco de mem√≥ria que cobre os bytes 8 a 15 (endere√ßos de mem√≥ria de 8 bytes alinhados) para pegar a primeira parte do valor; ent√£o, ter√° que acessar o bloco de mem√≥ria seguinte, que cobre os bytes 16 a 23, para pegar a parte restante do valor. Esse processo implica em dois ciclos de acesso √† mem√≥ria, o que √© menos eficiente.

# Conclus√£o

O acesso desalinhado resulta em mais opera√ß√µes de leitura ou escrita, aumentando a lat√™ncia e diminuindo a efici√™ncia do processador. Em contraste, acessos alinhados permitem que o processador realize uma opera√ß√£o √∫nica para ler ou escrever um dado completo.

Observa√ß√µes Importantes

- **Considera√ß√µes de Desempenho:** Organizar os campos de uma struct em ordem decrescente de tamanho pode melhorar o desempenho, pois minimiza a quantidade de padding necess√°ria.
- **Compatibilidade:** As regras de alinhamento s√£o essenciais para garantir a compatibilidade entre diferentes compiladores Go e diferentes arquiteturas de CPU.
- **Restri√ß√µes de Tamanho:**  O compilador imp√µe restri√ß√µes no tamanho m√°ximo de alguns tipos. Por exemplo, o tamanho total de uma struct n√£o pode exceder o tamanho m√°ximo do espa√ßo de endere√ßo.

Se os dados na `struct` n√£o est√£o alinhados, o compilador insere `padding` para alinha-los. Esse preenchimento de lacunas com bytes nulos prejudica a efici√™ncia do processamento, pois aumenta o tamanho da `struct` e, consequentemente, o uso de mem√≥ria [^4]. Para evitar que o compilador adicione `padding`, voc√™ pode alinhar manualmente os campos da `struct` ou utilizar um script que fa√ßa isso por voc√™ (o que √© mais recomendado).

---

[^1]: R. E. Bryant and D. R. O‚ÄôHallaron, Computer systems: a programmer‚Äôs perspective, Third edition. Boston.
[^2]: Barramentos de Dados ‚Äî Trafega dados entre mem√≥ria, processador e I/O; costuma ter a mesma largura que a word-size para transfer√™ncias de dados; Barramento de Endere√ßos ‚Äî A largura do barramento de endere√ßo determina a quantidade de mem√≥ria m√°xima endere√ßavel; trafega endere√ßos de mem√≥ria. Barramento de Controle ‚Äî trafega sinais para gerenciar todas as opera√ß√µes realizadas pelo sistema computacional..
[^3]: Uma CPU de 32 bits pode utilizar barramentos de 64 bits, ela pode solicitar dois blocos de 32 bits por ciclo, mas s√≥ continua limitada a processar 1 bloco de 32 bits por ciclo ainda.
[^4]: [Intel¬Æ FPGA SDK for OpenCL‚Ñ¢ Standard Edition: Best Practices Guide ‚Äî 3.5. Aligning a Struct with or without Padding](https://www.intel.com/content/www/us/en/docs/programmable/683176/18-1/aligning-a-struct-with-or-without-padding.html)

## Recursos

- [Part 2: Data Alignment, Padding, and Optimization Techniques](https://codeinterstellar.medium.com/part-2-data-alignment-padding-and-optimization-techniques-df2b2f2ba7e7)
