---
title: Alinhamento Estrutural de Dados e Otimiza√ß√£o de C√≥digo para Localidade Espacial-Temporal
description: Compreendendo alinhamento de dados, como ele √© aplicado na pr√°tica, quais s√£o as implica√ß√µes de n√£o alinhar os dados e como isso se relaciona com localidade espacial-temporal.
slug: data-structure-alignment-and-code-optimization-for-spatial-temporal-locality
image: /assets/blog/pt/edz-norton-ofja_9Ud9i0-unsplash.jpg
alternativeText: Pe√ßas de Scrabble formando a palavra "ALINHAMENTO" sobre um fundo branco.
caption: Foto de Edz Norton em Unsplash
publishedAt: 2024-12-01
updatedAt: 2024-12-01
category: theory
author: Maur√≠cio Witter
keywords: go, golang, memory, alignment, padding, cache, spatial-temporal coherence, optimization
---

# Contents

# 1 Introdu√ß√£o

**Data Alignment** n√£o √© um assunto t√£o popular entre grande parte dos desenvolvedores, mas est√° longe de ser um assunto herm√©tico ou esot√©rico. Mas esse assunto costuma estar long√≠nquo da base que √© ensinada em cursos universit√°rios e _bootcamps_. Eu mesmo n√£o cheguei a ver nada sobre isso no meu curso da faculdade, ent√£o restou para minha curiosidade dar conta de resolver e aqui estamos.

Neste post, vamos entender:

1. **O que √© Data Alignment**; 
2. **Como esse conceito est√° relacionado com a arquitetura computacional**; 
3. **Como ele √© aplicado na pr√°tica, com exemplos em [Go](https://go.dev/)**; 
4. **Quais s√£o as implica√ß√µes de n√£o alinhar os dados**; 
5. **Como alinhar os dados para evitar que o compilador adicione padding bytes desnecess√°rios** e 
6. **Entender como isso se relaciona com localidade espacial-temporal**.

# 2 Arquitetura Computacional e Hardware

O alinhamento de dados/bytes est√° intrinsecamente relacionado ao hardware, √† mem√≥ria virtual, ou como o sistema operacional a v√™ e ger√™ncia. Isso porque, dependendo da arquitetura, h√° uma padroniza√ß√£o de `word-size` e instru√ß√µes espec√≠ficas para cada arquitetura. Por exemplo, em arquiteturas x86-64, a CPU trabalha com 8 bytes (ou 64 bits) por ciclo. Mas por que 8 bytes? Bem, isso est√° relacionado ao fato de que sistemas computacionais operam com dados em [formato bin√°rio](https://www.wikiwand.com/pt/articles/Sistema_de_numera%C3%A7%C3%A3o_bin%C3%A1rio), ou seja, em pot√™ncias de 2 e 64 bits ‚Äî a gera√ß√£o seguinte da x86 (32 bits). A padroniza√ß√£o facilita o processamento eficiente e otimiza o acesso √† mem√≥ria, pois mant√©m as instru√ß√µes e dados alinhados com a largura do barramento de dados[^2][^3] da arquitetura e linhas de cache.

<Cite>
"Muitos sistemas de computador imp√µem restri√ß√µes aos endere√ßos permitidos para os tipos de dados primitivos, exigindo que o endere√ßo de algum tipo de objeto seja um m√∫ltiplo de algum valor K (normalmente 2, 4 ou 8)"[^1].
</Cite>

Em sistemas de 32 bits (x86), a CPU trabalha com 4 bytes (32 bits) por ciclo. Nesse caso, o alinhamento de dados em m√∫ltiplos de 4 bytes garante um acesso eficiente, evitando penalidades de desempenho. Arquiteturas de 16 bits, comuns em sistemas embarcados mais antigos, trabalham com 2 bytes (16 bits) por ciclo, enquanto em arquiteturas de 8 bits, a unidade m√≠nima √© de 1 byte por ciclo. H√°, tamb√©m, outras diversas arquiteturas que trabalham com 128 bits, 256 bits e assim por diante.

Portanto, o alinhamento de dados √© determinado pela arquitetura, pois tudo precisa estar "se comunicando na mesma linguagem" para que o sistema computacional como um todo possa trabalhar em harm√¥nia, evitando problemas de desempenho que ocorrem quando os dados est√£o desalinhados. Entretanto, a evolu√ß√£o dos algoritmos e conjuntos de instru√ß√µes tem feito otimiza√ß√µes importantes, que tornam o desalinhamento de dados menos problem√°tico, sendo que a diferen√ßa de desempenho √© torna-se quase impercept√≠vel em muitos casos.

Historicamente, reconhecia-se que as instru√ß√µes escalares geralmente apresentavam desempenho similar ao lidar com acessos a mem√≥ria desalinhada. Em contrapartida, as instru√ß√µes vetoriais, como as do SSE, frequentemente possu√≠am variantes espec√≠ficas para lidar com dados desalinhados, geralmente com uma penalidade de desempenho. O AVX introduziu melhorias no tratamento de dados desalinhados para algumas instru√ß√µes, reduzindo essa penalidade, mas o alinhamento ideal ainda √© recomendado para melhorar o desempenho, n√£o √© a toa que os compiladores ainda o fazem[^8].

Al√©m disso, alguns controladores DMA (Direct memory access) transferem dados em `bursts` alinhados a limites espec√≠ficos (semelhante √†s linhas de cache). Se os dados n√£o estiverem alinhados, o controlador pode precisar realizar m√∫ltiplas transfer√™ncias menores.

# 3 Data Alignment

Consoantante ao pr√≥prio nome, **Data Alignment** refere-se ao nivelamento dos dados na mem√≥ria para que eles sejam m√∫ltiplos do tamanho do seu pr√≥prio tipo ou de um m√∫ltiplo de algum valor K (2, 4 ou 8). Isso permite que a CPU acesse os dados em menos ciclos, pois o alinhamento garante que os dados sejam lidos ou escritos sem penalidades, aproveitando o tamanho da `word-size` da arquitetura.

<Cite>
"Por exemplo, suponha que um processador sempre busque 8 bytes da mem√≥ria com um endere√ßo que deve ser m√∫ltiplo de 8. Se pudermos garantir que qualquer `double` esteja alinhado para ter seu endere√ßo m√∫ltiplo de 8, ent√£o o valor pode ser lido ou escrito com uma √∫nica opera√ß√£o de mem√≥ria. Caso contr√°rio, poderemos precisar realizar dois acessos √† mem√≥ria, uma vez que o objeto pode ser dividido em dois blocos de mem√≥ria de 8 bytes."[^1]
</Cite>

Com essas defini√ß√µes em mente, vamos explorar a teoria b√°sica do alinhamento de bytes. Categoricamente, para compreender como fazer o alinhamento de bytes, precisamos saber para qual arquitetura estamos compilando, quantos bytes os tipos da linguagem ocupam e quais diretivas o compilador adota para alinhar os bytes.

Para este post, estarei utilizando uma arquitetura x86-64 e como linguagem [go](https://github.com/golang/go). Na se√ß√£o [3.1 Diretivas de Alinhamento](#31-diretivas-de-alinhamento), est√£o dispostos os tipos da linguagem e seus respectivos tamanhos e as regras de alinhamento do [compilador Go](https://github.com/golang/go).

## 3.1 Diretivas de Alinhamento

### 3.1.1 Diretivas Gerais

- **Alinhamento Padr√£o**: O alinhamento de um tipo √© determinado pelo tamanho do seu maior campo, at√© um m√°ximo de 8 bytes (o tamanho de um ponteiro em arquiteturas de 64 bits)[^9].

- **Arredondamento**: O tamanho de um tipo √© sempre arredondado para cima para ser um m√∫ltiplo do seu alinhamento. Isso garante que os tipos sejam armazenados em endere√ßos de mem√≥ria adequados[^9].

### 3.1.2 Diretivas de Alinhamento Espec√≠ficas

- `int8`, `uint8`, `bool`: Tamanho 1 byte, alinhamento 1 byte.
- `int16`, `uint16`: Tamanho 2 bytes, alinhamento 2 bytes.
- `int32`, `uint32`, `float32`: Tamanho 4 bytes, alinhamento 4 bytes.
- `int64`, `uint64`, `float64`, `complex128`: Tamanho 8 bytes, alinhamento igual ao tamanho da `word-size` da m√°quina (definido por `RegSize`).
- `complex64`: Tamanho 8 bytes, alinhamento 4 bytes.
- **Pointers** (`*T`, `unsafe.Pointer`): Tamanho e alinhamento iguais ao tamanho de um ponteiro (`PtrSize`).
- **Interfaces** (`interface{}`): Tamanho igual a dois ponteiros, alinhamento igual ao tamanho de um ponteiro.
- **Arrays** (`[n]T`): O tamanho √© um m√∫ltiplo do tamanho do elemento. O alinhamento √© igual ao alinhamento do elemento.
- **Structs** (`struct{...}`):
    - O alinhamento de uma estrutura √© o maior alinhamento de qualquer um dos seus campos.
    - O tamanho de uma struct √© o deslocamento do √∫ltimo campo, arredondado para cima para ser um m√∫ltiplo do alinhamento da struct.
    - Padding pode ser adicionado entre os campos de uma estrutura para garantir o alinhamento correto dos campos.
- **Strings** (`string`): Tamanho e alinhamento iguais ao tamanho de um ponteiro.
- **Slices** (`[]T`): Tamanho de tr√™s ponteiros, alinhamento igual ao tamanho de um ponteiro.
- **Channel** (`chan T`): Tamanho e alinhamento iguais ao tamanho de um ponteiro.
- **Maps** (`map[K]V`): Tamanho e alinhamento iguais ao tamanho de um ponteiro[^9].

<Warn title="Aten√ß√£o">
As vari√°veis `PtrSize` e `RegSize` s√£o definidas em **Build Time**, logo, s√£o do tamanho do `word-size` da arquitetura alvo[^9].
</Warn>

Fechando esse hiato de defini√ß√µes, agora finalmente podemos ir para a parte pr√°tica e ver como isso se aplica ao nosso c√≥digo.

## 3.2 Alinhamento pr√°tico

Na struct `Transaction`, foi definido alguns campos e alguns tipos primitivos para entendermos como o alinhamento de bytes funciona na pr√°tica.

```go showLineNumbers
type Transaction struct {
	Operation byte
	Quantity  int16
	Total     float64
	UnitPrice float32
	Balance   complex128
}
```

Bom, n√≥s j√° conhecemos o tipos e seus respectivos tamanhos, certo? Abordamos eles na se√ß√£o [3.1](#31-diretivas-de-alinhamento), ent√£o se somarmos esses tamanhos, teremos o tamanho total da nossa `struct`, correto?

$$
\begin{gathered}
\text{T} = & \ 1 + 2 + 8 + 4 + 16 \\
\text{T} = & \ 31 \text{ bytes}
\end{gathered}
$$

Teoricamente ter√≠amos $31$ bytes, quando alocada em uma mem√≥ria fict√≠cia que n√£o existe alinhamento. Cada bloco representando $1 \ byte$, `operation` ocupando 1 bloco, `quantity` 2 blocos, `total` 8 blocos, `unitPrice` 4 blocos e `balance` 16 blocos. Isso se parece com a [Figura 1](#1).

<Figure
  source="/assets/blog/pt/magic-memory.png"
  id="1"
  lang="pt"
  alt="Representa√ß√£o dos blocos de mem√≥ria se n√£o houvesse qualquer alinhamento de bytes."
  caption="Representa√ß√£o dos blocos de mem√≥ria se n√£o houvesse qualquer alinhamento de bytes."
/>

## 3.3 Padding Bytes

Em teoria, a struct `Transaction` deveria ter $31 \ bytes$, mas se verificarmos o tamanho da `struct`, veremos que ela tem $40 \ bytes$. O que h√° de errado? Bem, nada! Ocorre que, nossos campos da `struct` n√£o est√£o alinhados, ent√£o o compilador adicionou lacunas extras (**paddings** ou **gaps**) entre eles, para garantir que os campos estejam alinhados.

```go showLineNumbers
func main() {
	fmt.Printf("Struct Size: %d bytes\n", reflect.TypeOf(Transaction{}).Size())
	fmt.Println()
	t := reflect.TypeOf(Transaction{})
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(
      "Field: %s,
      Type: %s,
      Size: %d bytes\n",
      field.Name,
      field.Type,
      field.Type.Size()
    )
	}
}
```

```bash showLineNumbers
go run main.go
# Struct Size: 40 bytes

# Field: Operation, Type: uint8, Size: 1 bytes
# Field: Quantity, Type: int16, Size: 2 bytes
# Field: Total, Type: float64, Size: 8 bytes
# Field: UnitPrice, Type: float32, Size: 4 bytes
# Field: Balance, Type: complex128, Size: 16 bytes
```

Como resultado de alinhamento, o [go](https://go.dev/) adicionou essas lacunas entre os campos, mas n√£o precisou arredondar a estrutura final porque ela j√° termina alinhada, com o pr√≥ximo **offset** sendo um m√∫ltiplo de $8$ ‚Äî o $40$. A aloca√ß√£o dessa `struct` se pareceria com a [Figura 2](#2) agora.

<Figure
  source="/assets/blog/pt/memory-alignment-40-bytes.png"
  id="2"
  lang="pt"
  caption="Representa√ß√£o dos blocos de mem√≥ria com padding bytes. 1 bloco (unit8), 1 bloco de padding, 2 blocos (int16), 4 blocos padding, 8 blocos (float64), 4 blocos (float32), 4 blocos de padding, 16 blocos (complex128)."
  alt="Representa√ß√£o dos blocos de mem√≥ria com padding bytes. 1 bloco (unit8), 1 bloco de padding, 2 blocos (int16), 4 blocos padding, 8 blocos (float64), 4 blocos (float32), 4 blocos de padding, 16 blocos (complex128)."
/>


1. **`Operation` (byte):** Ocupa o bloco $1$ (offset $0$).
2. **`Quantity` (int16):**  Precisa ser alinhado em um endere√ßo m√∫ltiplo de $2$ (tamanho de um `int16`). Como o offset atual √© $1$, o compilador adicionar√° **1 byte de padding** no bloco $2$ para garantir o alinhamento correto de `Quantity` no bloco $3$ (offset $2$).
3. **`Total` (float64):** Requer alinhamento de $8$ bytes. O pr√≥ximo offset dispon√≠vel ap√≥s `Quantity` seria o $4$ (bloco $5$), mas ele precisa ser alinhado em um m√∫ltiplo de $8$.  Portanto, haver√° **4 bytes de padding** (blocos $4$, $5$, $6$ e $7$) antes de `Total`.
4. **`UnitPrice` (float32):**  Segue `Total` diretamente, ocupando $4$ bytes e mantendo o alinhamento.
5. **`Balance` (complex128):**  Esse tipo √© $16$ bytes, mas a diretiva diz que ele √© alinhado `RegSize`, na minha m√°quina (x84-64), isso √© $8$ bytes, mas como o pr√≥ximo bloco √© o 21 (offset $20$), ele precisa de **4 bytes de padding** (blocos $21$, $22$, $23$ e $24$) para garantir o alinhamento correto.

Se somarmos os tamanhos dos campos e os bytes de padding, teremos o tamanho total da `struct`:

$$
\begin{gathered}
T_{b} = & \ 1 + 2 + 8 + 4 + 16 \\
T_{p} = & \ 1 + 4 + 4 \\
T_{t} = & \ 31 + 9 \\
T_{t} = & \ 40 \text{ bytes}
\end{gathered}
$$

Como resultado final ter√≠amos uma `struct` de **$40$ bytes**, que poder√≠amos representar assim:

```go showLineNumbers
type TAlignment struct {
	Operation byte       // 0x00
	_         [1]byte    // 0x01
	Quantity  int16      // 0x02 - 0x03
	_         [4]byte    // 0x04 - 0x07
	Total     float64    // 0x08 - 0x0F
	UnitPrice float32    // 0x10 - 0x13
	_         [4]byte    // 0x14 - 0x17
	Balance   complex128 // 0x18 - 0x27
} // Total: 40 bytes
```

## 3.4 Pointer Bytes

Ponteiros s√£o um caso especial, pois o tamanho de um ponteiro √© o mesmo que o tamanho da `word-size` da arquitetura. Assim sendo, o alinhamento de um ponteiro √© o mesmo que o tamanho de um ponteiro. Em rotinas que alocam mem√≥ria, como `malloc` em [C](https://www.iso.org/standard/82075.html), ou `make`, `channels`, `slices` e `maps` em [Go](https://go.dev/)[^11][^12]. Assim sendo, o ponteiro retornado deve satisfazer a restri√ß√£o de alinhamento de pior caso para a m√°quina em que est√° sendo compilada.

<Cite>
As rotinas de biblioteca que alocam mem√≥ria, como `malloc`, devem ser projetadas de modo que retornem um ponteiro que satisfa√ßa a restri√ß√£o de alinhamento de pior caso para a m√°quina em que est√° sendo executada, normalmente 4 ou 8 bytes[^1].
</Cite>

### 3.4.1 Garbage Collection

O [Garbage Collector](https://tip.golang.org/doc/gc-guide) ‚Äî GC ‚Äî fica, dentre outras coisas, varrendo a mem√≥ria, em busca de ponteiros para objetos que n√£o est√£o mais sendo usados ou referenciados para, ent√£o, desaloca-los da mem√≥ria. <High>Dependendo de como o layout de mem√≥ria est√°, o GC pode precisar varrer mais bytes do que o necess√°rio, causando um overhead</High>.

```go showLineNumbers
type Token struct {
	File  *string
	Line  int
	Type  int
	Value []byte
}
```

Ent√£o qual √© a ideia aqui ü§î ? <High color="red">A indica√ß√£o √© para que se **adicione pointer bytes por primeiro** na struct</High>.

## 3.5 Implica√ß√µes

Voc√™ deve estar se perguntando: **"Por que uma struct com menos bytes (mesmo que desalinhada) possa ser menos eficiente que uma struct com mais bytes (alinhada)?"**. <High color="purple">Pois √©, essa foi a pergunta que me fez escrever este post</High>.

A principal raz√£o para isso √© a mem√≥ria cache da CPU. A mem√≥ria cache armazena dados em linhas de cache, que s√£o blocos de mem√≥ria de tamanho fixo. Quando a CPU precisa acessar um dado, primeiro verifica se ele est√° na mem√≥ria cache. Se estiver, √© uma "**cache hit**"[^5] e o dado √© recuperado rapidamente. Se n√£o estiver, √© um "**cache miss**"[^5] e a CPU precisa acessar a mem√≥ria principal, que √© muito mais lenta.

Quando os dados est√£o desalinhados, significa que seus membros podem cruzar os limites da linha de cache. Isso significa que, quando a CPU precisa acessar um membro de uma `struct`, ela pode precisar carregar duas linhas de cache em vez de uma. Isso dobra o n√∫mero de acessos √† mem√≥ria cache e pode levar a "cache misses" mais frequentes, penalizando o desempenho. Quando uma `struct` √© alinhada, todos os seus membros s√£o armazenados dentro da mesma linha de cache. Assim, ela s√≥ precisa carregar uma linha de cache, isso leva a "cache hits" mais frequentes.

Ent√£o √© por isso que √© melhor inserir alguns bytes a mais para garantir o alinhamento de bytes, do que ter um desempenho ruim por causa de "cache misses" frequentes. A tabela abaixo mostra os n√≠veis de cache e suas caracter√≠sticas (dados ilustrativos ‚Äî nem todo sistema computacional √© igual).


| N√≠vel | Tamanho | Lat√™ncia | Localiza√ß√£o      | Exemplo |
|-------|-----------------------|-------------------|----------------- | ------- | 
| L1    | 16‚Äì128 KB            | ~1‚Äì4 ciclos      | Por n√∫cleo       | Verifica L1. N√£o encontra (*miss*). |
| L2    | 128 KB‚Äì1 MB          | ~10 ciclos       | Por n√∫cleo       | Verifica L2. Encontra o dado (*hit*), carrega no L1. |
| L3    | 4‚Äì64 MB              | ~20‚Äì50 ciclos    | Compartilhado    | Caso n√£o estivesse no L2, L3 seria o pr√≥ximo n√≠vel. |
| RAM   | GBs                  | ~100‚Äì300 ciclos  | Fora do processador | Se n√£o estivesse no L3, a RAM seria acessada. |

## 3.6 Otimizando a struct `Transaction`

Uma otimiza√ß√£o de `Transaction` seria reorganizar os campos para que eles sejam alinhados corretamente.  A reorganiza√ß√£o dos campos √© a melhor op√ß√£o, pois n√£o adiciona bytes extras √† `struct`.

Na seguinte `struct` reorganizamos os campos para serem compat√≠veis com os m√∫ltiplos de seus alinhamentos, como visto na se√ß√£o [3.1](#31-diretivas-de-alinhamento). Ainda houve a necessidade de adicionar 1 byte de padding antes de `Total` porque um `float64` precisa de um alinhamento de 8 bytes e o pr√≥ximo offset dispon√≠vel era 23, que n√£o √© um m√∫ltiplo de 8. No fim, ficamos com uma `struct` alinhada de 32 bytes.

```go showLineNumbers
type Transaction struct {
	Balance   complex128 // offset 0-15 - 16 bytes
	UnitPrice float32    // offset 16-19 - 4 bytes
	Quantity  int16      // offset 20-21 - 2 bytes
	Operation byte       // offset 22 - 1 byte
	Total     float64    // offset 24-31 - 8 bytes (padding 1 byte)
} // Total: 32 bytes
```

Desta outra maneira, obtemos uma otimiza√ß√£o de $30$ bytes **aparente**, mas como foi dito na se√ß√£o [3.1.1](#311-diretivas-gerais), o tamanho √© arredondado para cima para ser um m√∫ltiplo do seu do seu alinhamento ou de `RegSize`, ent√£o o tamanho final da `struct` ainda seria 32 bytes, ou seja, o tamanho m√≠nimo que poder√≠amos obter para ela, quando alinhada para esta `struct`.

```go showLineNumbers
type Transaction struct {
	Total     float64    // offset 0-7 - 8 bytes
	Balance   complex128 // offset 8-23 - 16 bytes
	UnitPrice float32    // offset 24-27 - 4 bytes
	Quantity  int16      // offset 28-29 - 2 bytes
	Operation byte       // offset 30 - 1 byte
} // Total: 32 bytes
```

Enfim, existem $n$ maneiras de organizar a `struct` para que ela seja alinhada, mas ela sempre ter√° um tamanho m√≠nimo, alinhado ao offset que seja um m√∫ltiplo do seu alinhamento. No caso de `Transaction`, a base minima √© $32$ bytes. Mas voc√™ ainda pode organizar essa struct conforme o seu modelo de uso para obter a efici√™ncia m√°xima, como colocar pointers bytes primeiro, ou os campos que s√£o mais acessados juntos, ou os campos que s√£o acessados com mais frequ√™ncia.

## 3.7 Localidade Espacial-Temporal

A localidade espacial-temporal √© explorada pelos sistemas de cache para melhorar o desempenho, e essa localidade tamb√©m adv√©m de um bom alinhamento. Quando uma linha de cache √© carregada, **ela cont√©m n√£o apenas o dado solicitado, mas tamb√©m os dados adjacentes (localidade espacial)**. Se o programa exibir boa localidade espacial, esses dados adjacentes provavelmente ser√£o usados em breve, resultando em "cache hits". Da mesma forma, **se um dado for acessado repetidamente (localidade temporal), ele permanecer√° no cache por mais tempo**, evitando acessos √† mem√≥ria principal[^7][^10].

### 3.7.1 Localidade Espacial

Quando um programa acessa um dado na mem√≥ria, h√° uma probabilidade muito alta de que ele acesse dados adjacentes em seguida. Isso ocorre frequentemente em loops que percorrem arrays ou estruturas de dados cont√≠guas como listas ligadas. A performance √© significativamente melhor quando os elementos s√£o armazenados sequencialmente na mem√≥ria. A localidade espacial justifica a busca de blocos de mem√≥ria maiores que um √∫nico dado (linhas de cache) quando ocorre um "cache miss", ent√£o a CPU busca a linha de cache inteira que cont√©m o dado solicitado, antecipando acessos a dados pr√≥ximos[^7][^10].

### 3.7.2 Localidade Temporal

Um programa tamb√©m tende a acessar os mesmos dados repetidamente em curtos intervalos de tempo, em contrapartida, √© ineficaz para acessos aleat√≥rios, ou seja, o _prefetching_ √© menos eficaz e a taxa de "cache misses" aumenta, degradando significativamente o desempenho. A localidade temporal √© a raz√£o pela qual manter dados usados frequentemente nos caches de n√≠vel superior (L1 e L2) √© t√£o importante[^7][^10].

# 4 Conclus√£o

Passamos por v√°rios t√≥picos nesse post, t√≥picos relacionados ao alinhamento de bytes que permitem que nossos programas fa√ßam uso eficiente do cache da CPU, DMA e localidade espacial-temporal. Hodiernamente, as instru√ß√µes de CPU est√£o mais otimizadas, mas o alinhamento de bytes ainda √© importante para garantir o desempenho do sistema computacional.

Aprendemos que o alinhamento de bytes √© um conceito importante para o desempenho do sistema computacional, pois permite que a CPU acesse os dados de forma eficiente, evitando penalidades de desempenho. Vimos como o alinhamento de bytes √© determinado pela arquitetura e como o compilador Go alinha os tipos de dados.

Agora voc√™ j√° sabe como alinhar seus dados manualmente atrav√©s de aritm√©tica simples, calculando os offsets dos tipos de dados e identificando quais posi√ß√µes eles devem ocupar sem que o compilador adicione paddings in√∫teis para preencher os espa√ßos entre os campos desalinhados. Mas, isso pode ser tedioso quando voc√™ tem muitas `structs`e tipos de dados, ent√£o voc√™ pode usar o pacote [fieldalignment](https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment) ou o [betteralign](https://github.com/dkorunic/betteralign) para fazer isso por voc√™.

```bash showLineNumbers
# Fieldalignment
go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest
fieldalignment --help
```

```bash showLineNumbers
# Betteralign
go install github.com/dkorunic/betteralign/cmd/betteralign@latest
betteralign --help
```

Espero que este post tenha sido √∫til e que voc√™ tenha aprendido algo novo. Se voc√™ tiver alguma d√∫vida ou sugest√£o, [sinta-se √† vontade para deixar um coment√°rio](https://github.com/rwietter/rwietter.dev). Obrigado por ler!

[^1]: R. E. Bryant and D. R. O‚ÄôHallaron, Computer systems: a programmer‚Äôs perspective, Third edition. Boston.
[^2]: Barramentos de Dados ‚Äî Trafega dados entre mem√≥ria, processador e I/O; costuma ter a mesma largura que a word-size para transfer√™ncias de dados; Barramento de Endere√ßos ‚Äî A largura do barramento de endere√ßo determina a quantidade de mem√≥ria m√°xima endere√ß√°vel; trafega endere√ßos de mem√≥ria. Barramento de Controle ‚Äî trafega sinais para gerenciar todas as opera√ß√µes realizadas pelo sistema computacional..
[^3]: Uma CPU de 32 bits pode utilizar barramentos de 64 bits, ela pode solicitar dois blocos de 32 bits por ciclo, mas s√≥ continua limitada a processar 1 bloco de 32 bits por ciclo ainda.
[^4]: [Intel¬Æ FPGA SDK for OpenCL‚Ñ¢ Standard Edition: Best Practices Guide ‚Äî 3.5. Aligning a Struct with or without Padding](https://www.intel.com/content/www/us/en/docs/programmable/683176/18-1/aligning-a-struct-with-or-without-padding.html)
[^5]: [Cache (computing)](https://www.wikiwand.com/en/articles/Cache_(computing))
[^6]: [Pointers Are Complicated, or: What's in a Byte?](https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html)
[^7]: [What every programmer should know about memory ‚Äî Memory part 2: CPU caches](https://lwn.net/Articles/252125/)
[^8]: [Reddit: How big a deal is memory alignment these days (on x86)?](https://www.reddit.com/r/C_Programming/comments/na4l6v/how_big_a_deal_is_memory_alignment_these_days_on/)
[^9]: [Go Compiler: Align](https://github.com/golang/go/blob/356ba0f06586a833cd8de9c04af0d2adddf95851/src/cmd/compile/internal/types/size.go)
[^10]: [MC542: Organiza√ß√£o de Computadores Teoria e Pr√°tica](https://www.ic.unicamp.br/~ducatte/mc542/Slides/mc542_A_05_2s07.pdf)
[^11]: [A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)
[^12]: [Go Memory Model](https://go.dev/ref/mem)